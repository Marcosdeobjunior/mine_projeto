<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universo de Poderes - Batalha por Turnos</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a2e; --surface-color: #2a2a4e; --primary-color: #00ffff;
            --secondary-color: #ff00ff; --text-color: #e0e0ff; --text-muted: #8c8ca0;
            --border-color: #4a4a7f; --glow-color: rgba(0, 255, 255, 0.5);
            --font-display: 'Roboto Condensed', sans-serif; --font-mono: 'Share Tech Mono', monospace;
            --xp-color: #FFC107; --danger-color: #ff453a; --success-color: #00ff88;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: var(--font-mono); background-color: var(--bg-color); color: var(--text-color); padding: 2rem; display: flex; flex-direction: column; align-items: center; }
        .container { width: 100%; max-width: 1400px; }
        .btn { font-family: var(--font-display); font-size: 1.1rem; text-transform: uppercase; padding: 0.7rem 1.2rem; border: 2px solid var(--primary-color); border-radius: 4px; background-color: transparent; color: var(--primary-color); cursor: pointer; transition: all 0.2s; box-shadow: 0 0 8px var(--glow-color); }
        .btn:hover { background-color: var(--primary-color); color: var(--bg-color); }
        .btn:disabled { border-color: var(--text-muted); color: var(--text-muted); box-shadow: none; cursor: not-allowed; opacity: 0.5; }
        header { text-align: center; margin-bottom: 1.5rem; }
        header h1 { font-family: var(--font-display); font-size: 2.5rem; text-transform: uppercase; color: var(--primary-color); text-shadow: 0 0 10px var(--glow-color), 0 0 20px var(--secondary-color); }
        .main-controls { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 1rem; background-color: var(--surface-color); padding: 1rem; border-radius: 8px; margin-bottom: 2rem; border: 1px solid var(--border-color); }
        .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
        .control-group label { font-size: 0.8rem; text-align: center; color: var(--text-muted); }
        .control-group select { background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; font-family: var(--font-mono); }
        .battle-arena { display: grid; grid-template-columns: 1fr auto 1fr; gap: 2rem; align-items: flex-start; }
        .power-slot { background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; min-height: 620px; display: flex; flex-direction: column; box-shadow: 0 0 15px rgba(0,0,0,0.5); transition: all 0.3s ease-in-out; }
        .power-card { display: none; flex-direction: column; gap: 1rem; flex-grow: 1; }
        .power-header { display: flex; justify-content: space-between; align-items: flex-start; border-bottom: 2px solid var(--border-color); padding-bottom: 1rem; }
        .power-name { font-family: var(--font-display); font-size: 1.8rem; text-transform: uppercase; line-height: 1.2; margin-bottom: 0.5rem; }
        .power-level { font-size: 2.5rem; font-weight: bold; flex-shrink: 0; margin-left: 1rem; text-shadow: 0 0 5px var(--secondary-color); }
        .power-rarity { font-size: 1rem; font-weight: bold; padding: 5px 10px; border-radius: 4px; }
        .power-card h3 { font-family: var(--font-display); text-transform: uppercase; font-size: 1.2rem; color: var(--primary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; margin: 1rem 0 0.5rem 0; }
        .power-card ul { list-style: none; padding-left: 0; } .power-card ul li { margin-bottom: 0.5rem; line-height: 1.4; }
        .power-actions { display: flex; gap: 1rem; margin-top: auto; }
        .battle-controls { display: flex; flex-direction: column; gap: 1rem; align-items: center; justify-content: center; }
        #battle-result { margin-top: 2rem; font-family: var(--font-mono); min-height: 150px; background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; white-space: pre-wrap; max-height: 400px; overflow-y: auto; }
        .rarity-comum { background-color: #9E9E9E; color: #111; } .rarity-incomum { background-color: #4CAF50; color: #fff; } .rarity-raro { background-color: #2196F3; color: #fff; } .rarity-epico { background-color: #9C27B0; color: #fff; } .rarity-lendario { background-color: #FFC107; color: #111; } .rarity-mitico { border: 2px solid #fff; background: linear-gradient(45deg, #ff00ff, #00ffff); color: #fff; }
        
        .domain-fogo { border-color: #ff6a00; } .domain-agua { border-color: #00aaff; } .domain-arcano { border-color: #c400ff; } .domain-natureza { border-color: #00ff88; } .domain-gelo { border-color: #88ddff; }
        @keyframes battle-clash { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @keyframes winner-glow { 0%, 100% { box-shadow: 0 0 25px var(--xp-color); } 50% { box-shadow: 0 0 10px var(--xp-color); } }
        @keyframes loser-fade { to { opacity: 0.6; transform: scale(0.98); } }
        .battle-clash { animation: battle-clash 0.5s ease-in-out; }
        .winner-glow { animation: winner-glow 1.5s ease-in-out infinite; }
        .loser-fade { animation: loser-fade 0.5s forwards; }
        
        /* --- NOVOS ESTILOS PARA BATALHA --- */
        .status-bar { width: 100%; height: 20px; background-color: #111; border-radius: 4px; overflow: hidden; margin-top: 0.5rem; position: relative; border: 1px solid var(--border-color); }
        .status-bar .bar-fill { height: 100%; transition: width 0.3s ease-in-out; }
        .status-bar .bar-text { position: absolute; top: 0; left: 0; width: 100%; text-align: center; font-size: 0.8rem; line-height: 20px; color: white; text-shadow: 1px 1px 1px #000; font-weight: bold; }
        .hp-bar .bar-fill { background-color: var(--danger-color); }
        .mp-bar .bar-fill { background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); }

        #manual-controls { margin-top: 1rem; background-color: var(--surface-color); border: 2px solid var(--secondary-color); box-shadow: 0 0 15px var(--secondary-color); border-radius: 8px; padding: 1rem; display: none; flex-direction: column; gap: 0.5rem; }
        #manual-controls h3 { text-align: center; margin-bottom: 0.5rem; font-family: var(--font-display); color: var(--secondary-color); }
        #manual-controls .ability-btn { display: flex; justify-content: space-between; width: 100%; text-align: left; }
        #manual-controls .ability-btn span:last-child { font-weight: bold; color: var(--primary-color); }

        @media (max-width: 900px) { body { padding: 1rem; } .battle-arena { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <header><h1>Universo de Poderes</h1></header>
        <div class="main-controls">
            <div class="control-group"><label for="rarity-filter">Raridade</label><select id="rarity-filter"><option value="any">Qualquer</option></select></div>
            <div class="control-group"><label for="domain-filter">Domínio</label><select id="domain-filter"><option value="any">Qualquer</option></select></div>
            <button class="btn" id="generate-filtered-btn">Gerar para A</button>
        </div>
        <div class="battle-arena">
            <div class="power-slot" id="power-a">
                <div class="power-card">
                    <div class="power-header">
                        <div><div class="power-name"></div><div class="power-rarity"></div></div>
                        <div class="power-level"></div>
                    </div>
                    <div class="status-bar hp-bar"><div class="bar-fill"></div><span class="bar-text"></span></div>
                    <div class="status-bar mp-bar"><div class="bar-fill"></div><span class="bar-text"></span></div>
                    <p class="power-description"></p>
                    <div><h3>Habilidades</h3><ul class="abilities-list"></ul></div>
                </div>
                <div class="power-actions"><button class="btn generate-btn" data-slot="a">Gerar Aleatório</button></div>
            </div>

            <div class="battle-controls">
                <button class="btn" id="auto-battle-btn" disabled>Batalha Automática</button>
                <button class="btn" id="manual-battle-btn" disabled>Batalha Manual</button>
            </div>

            <div class="power-slot" id="power-b">
                <div class="power-card">
                    <div class="power-header">
                        <div><div class="power-name"></div><div class="power-rarity"></div></div>
                        <div class="power-level"></div>
                    </div>
                    <div class="status-bar hp-bar"><div class="bar-fill"></div><span class="bar-text"></span></div>
                    <div class="status-bar mp-bar"><div class="bar-fill"></div><span class="bar-text"></span></div>
                    <p class="power-description"></p>
                    <div><h3>Habilidades</h3><ul class="abilities-list"></ul></div>
                </div>
                <div class="power-actions"><button class="btn generate-btn" data-slot="b">Gerar Aleatório</button></div>
            </div>
        </div>
        <div id="manual-controls"></div>
        <div class="battle-result" id="battle-result">Aguardando combatentes...</div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- BANCO DE DADOS INTERNO ---
        const rarities = { comum: { name: 'Comum', score: 1, weight: 40 }, incomum: { name: 'Incomum', score: 2, weight: 30 }, raro: { name: 'Raro', score: 4, weight: 15 }, epico: { name: 'Épico', score: 8, weight: 9 }, lendario: { name: 'Lendário', score: 16, weight: 4 }, mitico: { name: 'Mítico', score: 32, weight: 1.5 } };
        const levels = { E: { name: 'E', score: 1 }, D: { name: 'D', score: 2 }, C: { name: 'C', score: 4 }, B: { name: 'B', score: 8 }, A: { name: 'A', score: 16 }, S: { name: 'S', score: 32 }, SS: { name: 'SS', score: 64 }, SSS: { name: 'SSS', score: 128 } };
        
        // --- REESTRUTURAÇÃO DAS HABILIDADES PARA O SISTEMA DE BATALHA ---
        const domains = {
            fogo: { name: 'Fogo', names: ['Pirocinese', 'Coração de Magma'], advantage: 'natureza', 
                abilities: [
                    { name: 'Bola de Fogo', mpCost: 15, damageMultiplier: 1.2, description: 'Um ataque de fogo básico e direto.' },
                    { name: 'Manto de Chamas', mpCost: 25, damageMultiplier: 0.8, description: 'Cobre-se em fogo para um ataque amplo.' },
                    { name: 'Explosão de Plasma', mpCost: 40, damageMultiplier: 1.8, description: 'Um ataque poderoso e custoso.' }
                ]},
            agua: { name: 'Água', names: ['Hidrocinese', 'Maré Viva'], advantage: 'fogo', 
                abilities: [
                    { name: 'Jato d\'Água', mpCost: 12, damageMultiplier: 1.1, description: 'Dispara um jato de água pressurizada.' },
                    { name: 'Vórtice Aquático', mpCost: 28, damageMultiplier: 1.5, description: 'Cria um redemoinho que aprisiona e fere.' },
                    { name: 'Onda Curativa', mpCost: 35, damageMultiplier: -1, description: 'Usa a água para curar 50 de HP.' } // Habilidade de cura (multiplicador negativo)
                ]},
            natureza: { name: 'Natureza', names: ['Guardião Verde', 'Coração da Floresta'], advantage: 'gelo', 
                abilities: [
                    { name: 'Chicote de Cipó', mpCost: 10, damageMultiplier: 1.0, description: 'Ataca com cipós afiados.' },
                    { name: 'Esporos Paralisantes', mpCost: 20, damageMultiplier: 0.5, description: 'Libera esporos que podem atordoar o inimigo.' },
                    { name: 'Fúria da Floresta', mpCost: 45, damageMultiplier: 2.0, description: 'A força da natureza em um golpe devastador.' }
                ]},
            gelo: { name: 'Gelo', names: ['Criocinese', 'Zero Absoluto'], advantage: 'agua', 
                abilities: [
                    { name: 'Lança de Gelo', mpCost: 18, damageMultiplier: 1.3, description: 'Cria e dispara uma lança de gelo pontiaguda.' },
                    { name: 'Muralha Glacial', mpCost: 22, damageMultiplier: 0, description: 'Aumenta a defesa temporariamente (não implementado).' },
                    { name: 'Nevasca', mpCost: 38, damageMultiplier: 1.7, description: 'Cria uma tempestade de gelo na área.' }
                ]}
        };

        // --- VARIÁVEIS GLOBAIS ---
        let powerA = null;
        let powerB = null;

        // --- ESTADO DA BATALHA ---
        const battleState = {
            active: false,
            mode: 'auto',
            turn: 'a',
            combatantA: null,
            combatantB: null,
            log: []
        };
        
        // --- ELEMENTOS DO DOM ---
        const autoBattleBtn = document.getElementById('auto-battle-btn');
        const manualBattleBtn = document.getElementById('manual-battle-btn');
        const resultEl = document.getElementById('battle-result');
        const rarityFilter = document.getElementById('rarity-filter');
        const domainFilter = document.getElementById('domain-filter');
        const manualControlsEl = document.getElementById('manual-controls');

        // --- FUNÇÕES UTILITÁRIAS ---
        const weightedRandom = (items) => { const total = Object.values(items).reduce((s, i) => s + i.weight, 0); let r = Math.random() * total; for (const k in items) { if (r < items[k].weight) return k; r -= items[k].weight; } };
        const getRandomKey = (obj) => { const keys = Object.keys(obj); return keys[Math.floor(Math.random() * keys.length)]; };
        const getRandomSample = (arr, n) => [...arr].sort(() => 0.5 - Math.random()).slice(0, n);
        
        /**
         * Gera um novo poder com base em raridade, nível e domínio.
         * AGORA INCLUI HP e MP.
         */
        function generatePower(options = {}) {
            const rarityKey = options.rarity && options.rarity !== 'any' ? options.rarity : weightedRandom(rarities);
            const domainKey = options.domain && options.domain !== 'any' ? options.domain : getRandomKey(domains);
            const rarity = rarities[rarityKey];
            const domain = domains[domainKey];
            const levelKey = getRandomKey(levels);
            const level = levels[levelKey];
            
            const powerName = getRandomSample(domain.names, 1)[0] || `Poder de ${domain.name}`;
            const description = `Um poder do domínio da ${domain.name} com manifestação de nível ${level.name}.`;

            // Geração de HP e MP baseada em atributos
            const maxHp = Math.round(100 + (rarity.score * 15) + (level.score * 8));
            const maxMp = Math.round(50 + (rarity.score * 8) + (level.score * 12));

            // Seleciona 3 habilidades aleatórias do domínio
            const selectedAbilities = getRandomSample(domain.abilities, 3);

            return { name: powerName, rarityKey, rarity, levelKey, level, domainKey, domain, description, abilities: selectedAbilities, maxHp, hp: maxHp, maxMp, mp: maxMp, uid: Date.now() + Math.random() };
        }
        
        /**
         * Renderiza um poder em um dos slots da arena.
         * ATUALIZADO para mostrar HP/MP e a nova estrutura de habilidades.
         */
        function renderPower(power, slot) {
            const slotEl = document.getElementById(`power-${slot}`); if (!slotEl) return;
            slotEl.className = `power-slot domain-${power.domainKey}`;
            const cardEl = slotEl.querySelector('.power-card');
            cardEl.querySelector('.power-name').textContent = power.name;
            const rarityEl = cardEl.querySelector('.power-rarity');
            rarityEl.textContent = power.rarity.name;
            rarityEl.className = `power-rarity rarity-${power.rarityKey}`;
            cardEl.querySelector('.power-level').textContent = power.level.name;
            cardEl.querySelector('.power-description').textContent = power.description;
            
            // Exibe a lista de habilidades com custo de MP e descrição
            cardEl.querySelector('.abilities-list').innerHTML = power.abilities.map(ab => `<li><strong>${ab.name}</strong> (MP: ${ab.mpCost})<br><small>${ab.description}</small></li>`).join('');
            
            updateStatusBars(power, slotEl);

            cardEl.style.display = 'flex';
        }

        /**
         * Atualiza as barras de status (HP/MP) de um poder.
         */
        function updateStatusBars(power, slotEl) {
            const hpBar = slotEl.querySelector('.hp-bar');
            const hpPercent = (power.hp / power.maxHp) * 100;
            hpBar.querySelector('.bar-fill').style.width = `${hpPercent}%`;
            hpBar.querySelector('.bar-text').textContent = `HP: ${power.hp} / ${power.maxHp}`;

            const mpBar = slotEl.querySelector('.mp-bar');
            const mpPercent = (power.mp / power.maxMp) * 100;
            mpBar.querySelector('.bar-fill').style.width = `${mpPercent}%`;
            mpBar.querySelector('.bar-text').textContent = `MP: ${power.mp} / ${power.maxMp}`;
        }
        
        /**
         * Função principal para gerar e exibir um poder em um slot.
         */
        function generateAndRender(slot, options = {}) { 
            const newPower = generatePower(options); 
            if (slot === 'a') powerA = newPower; else powerB = newPower; 
            renderPower(newPower, slot); 
            
            // Habilita botões de batalha apenas se ambos os slots tiverem poderes
            const bothReady = powerA && powerB;
            autoBattleBtn.disabled = !bothReady;
            manualBattleBtn.disabled = !bothReady;
        }

        // --- SEÇÃO DE LÓGICA DE BATALHA POR TURNOS ---

        /**
         * Inicia a batalha, configurando o estado inicial.
         * @param {string} mode - 'Automática' ou 'Manual'.
         */
        function startBattle(mode) {
            if (!powerA || !powerB || battleState.active) return;

            battleState.active = true;
            battleState.mode = mode;
            // Cria clones profundos para não alterar os poderes originais durante a batalha
            battleState.combatantA = JSON.parse(JSON.stringify(powerA));
            battleState.combatantB = JSON.parse(JSON.stringify(powerB));
            battleState.turn = 'a';
            battleState.log = [`A Batalha ${mode} Começou!`, `${powerA.name} VS ${powerB.name}`];
            
            updateBattleLog();
            disableControls(true); // Desativa botões de geração e de início de batalha
            
            setTimeout(nextTurn, 1000); // Inicia o primeiro turno após 1 segundo
        }

        /**
         * Controla o fluxo de turnos da batalha.
         */
        function nextTurn() {
            if (!battleState.active) return;
            
            const attacker = battleState.turn === 'a' ? battleState.combatantA : battleState.combatantB;

            // CONDIÇÃO DE DERROTA: Se o atacante não tiver MP para NENHUMA habilidade, ele perde.
            const canAttack = attacker.abilities.some(ability => attacker.mp >= ability.mpCost);
            if (!canAttack) {
                battleState.log.push(`---`);
                battleState.log.push(`${attacker.name} não tem mais MP para lutar!`);
                const winner = battleState.turn === 'a' ? battleState.combatantB : battleState.combatantA;
                endBattle(winner, `${attacker.name} perdeu por exaustão de mana!`);
                return;
            }
            
            battleState.log.push(`---`);
            battleState.log.push(`É a vez de ${attacker.name}! (HP: ${attacker.hp}, MP: ${attacker.mp})`);
            updateBattleLog();

            if (battleState.mode === 'Automática') {
                // IA Simples: escolhe a habilidade de maior dano que pode pagar
                const availableAbilities = attacker.abilities
                    .filter(a => attacker.mp >= a.mpCost && a.damageMultiplier > 0)
                    .sort((a, b) => b.damageMultiplier - a.damageMultiplier);
                
                // Se não houver habilidades de ataque, usa uma aleatória que pode pagar
                const chosenAbility = availableAbilities.length > 0 ? availableAbilities[0] : getRandomSample(attacker.abilities.filter(a => attacker.mp >= a.mpCost), 1)[0];
                
                setTimeout(() => executeTurn(chosenAbility), 1500); // Espera 1.5s antes da ação da IA
            } else {
                // Modo Manual: Exibe os controles para o jogador
                showManualControls();
            }
        }

        /**
         * Executa a ação de um turno (ataque ou cura).
         * @param {object} ability - A habilidade escolhida.
         */
        function executeTurn(ability) {
            manualControlsEl.style.display = 'none'; // Esconde os controles manuais

            const attacker = battleState.turn === 'a' ? battleState.combatantA : battleState.combatantB;
            const defender = battleState.turn === 'a' ? battleState.combatantB : battleState.combatantA;

            // Paga o custo de MP
            attacker.mp -= ability.mpCost;
            battleState.log.push(`${attacker.name} usa ${ability.name}! (-${ability.mpCost} MP)`);

            // Habilidade de cura
            if(ability.damageMultiplier < 0) {
                const healAmount = 50; // Valor de cura fixo para o exemplo
                attacker.hp = Math.min(attacker.maxHp, attacker.hp + healAmount);
                battleState.log.push(`${attacker.name} se cura em ${healAmount} HP!`);
            } else {
                // Habilidade de dano
                // Fórmula de dano: (base dos scores * multiplicador da skill) * variação aleatória
                let damage = Math.round(((attacker.level.score * 5 + attacker.rarity.score * 10) * ability.damageMultiplier) * (Math.random() * 0.4 + 0.8));
                
                // Verifica vantagem de domínio
                if (domains[attacker.domainKey].advantage === defender.domainKey) {
                    damage = Math.round(damage * 1.5);
                    battleState.log.push(`É super efetivo!`);
                }
                
                defender.hp = Math.max(0, defender.hp - damage);
                battleState.log.push(`${defender.name} sofre ${damage} de dano!`);
            }

            updateBattleUI();

            // Verifica se a batalha terminou
            if (defender.hp <= 0) {
                endBattle(attacker, `${defender.name} foi derrotado!`);
            } else {
                // Passa para o próximo turno
                battleState.turn = (battleState.turn === 'a' ? 'b' : 'a');
                setTimeout(nextTurn, 2000); // Espera 2s antes do próximo turno
            }
        }

        /**
         * Finaliza a batalha e declara o vencedor.
         */
        function endBattle(winner, message) {
            battleState.log.push(`---`);
            battleState.log.push(`FIM DA BATALHA!`);
            battleState.log.push(message);
            battleState.log.push(`${winner.name} é o vencedor!`);
            
            updateBattleLog();
            
            // Reset state
            battleState.active = false;
            disableControls(false); // Reativa os controles
        }
        
        /**
         * Atualiza toda a UI relacionada à batalha (barras e log).
         */
        function updateBattleUI() {
            updateStatusBars(battleState.combatantA, document.getElementById('power-a'));
            updateStatusBars(battleState.combatantB, document.getElementById('power-b'));
            updateBattleLog();
        }

        /**
         * Atualiza o painel de log da batalha.
         */
        function updateBattleLog() {
            resultEl.innerHTML = battleState.log.join('\n');
            resultEl.scrollTop = resultEl.scrollHeight; // Rola para o final
        }

        /**
         * Mostra o painel de controle para batalhas manuais.
         */
        function showManualControls() {
            const attacker = battleState.turn === 'a' ? battleState.combatantA : battleState.combatantB;
            manualControlsEl.innerHTML = `<h3>Escolha a ação de ${attacker.name}</h3>`;
            
            attacker.abilities.forEach(ability => {
                const btn = document.createElement('button');
                btn.className = 'btn ability-btn';
                btn.innerHTML = `<span>${ability.name} (${ability.description})</span> <span>${ability.mpCost} MP</span>`;
                // Desabilita o botão se não houver MP suficiente
                btn.disabled = attacker.mp < ability.mpCost;
                btn.onclick = () => {
                    executeTurn(ability);
                };
                manualControlsEl.appendChild(btn);
            });
            manualControlsEl.style.display = 'flex';
        }

        /**
         * Habilita ou desabilita os controles principais da página.
         * @param {boolean} battling - True se uma batalha está em andamento.
         */
        function disableControls(battling) {
            autoBattleBtn.disabled = battling || !powerA || !powerB;
            manualBattleBtn.disabled = battling || !powerA || !powerB;
            document.querySelectorAll('.generate-btn').forEach(btn => btn.disabled = battling);
            document.getElementById('generate-filtered-btn').disabled = battling;
        }

        // --- INICIALIZAÇÃO E EVENT LISTENERS ---

        document.querySelectorAll('.generate-btn').forEach(btn => btn.addEventListener('click', () => generateAndRender(btn.dataset.slot)));
        document.getElementById('generate-filtered-btn').addEventListener('click', () => generateAndRender('a', { rarity: rarityFilter.value, domain: domainFilter.value }));
        
        autoBattleBtn.addEventListener('click', () => startBattle('Automática'));
        manualBattleBtn.addEventListener('click', () => startBattle('Manual'));

        function populateFilters() {
            Object.keys(rarities).forEach(key => rarityFilter.innerHTML += `<option value="${key}">${rarities[key].name}</option>`);
            Object.keys(domains).forEach(key => domainFilter.innerHTML += `<option value="${key}">${domains[key].name}</option>`);
        }
        
        // --- CÓDIGO INICIAL ---
        populateFilters();
        generateAndRender('a');
        generateAndRender('b');
    });
    </script>
</body>
</html>
